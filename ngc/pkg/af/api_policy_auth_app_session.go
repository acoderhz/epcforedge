/*
 * Npcf_PolicyAuthorization Service API
 *
 * This is the Policy Authorization Service
 *
 * API version: 1.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package af

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	/*
		_neturl "net/url"
	*/)

// Linger please
var (
	_ _context.Context
)

// PolicyAuthAppSessionApiService ApplicationSessionsCollectionApi service
type PolicyAuthAppSessionApiService policyAuthService

/*
PostAppSessions Creates a new Individual Application Session Context resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appSessionContext Contains the information for the creation the resource
@return AppSessionContext
*/
func (a *PolicyAuthAppSessionApiService) PostAppSessions(ctx _context.Context, appSessionContext AppSessionContext) (AppSessionContext, *_nethttp.Response, error) {
	var (
		httpMethod = _nethttp.MethodPost
		postBody   interface{}
		retVal     AppSessionContext
	)

	// create path and map variables
	path := a.client.cfg.Protocol + "://" + a.client.cfg.PcfHostname +
		a.client.cfg.PcfPort + a.client.cfg.PolicyAuthBasePath +
		"/app-sessions"
	headerParams := make(map[string]string)

	// to determine the Content-Type header
	httpContentTypes := []string{"application/json"}

	// set Content-Type header
	httpContentType := selectHeaderContentType(httpContentTypes)
	if httpContentType != "" {
		headerParams["Content-Type"] = httpContentType
	}

	// to determine the Accept header
	httpHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	httpHeaderAccept := selectHeaderAccept(httpHeaderAccepts)
	if httpHeaderAccept != "" {
		headerParams["Accept"] = httpHeaderAccept
	}
	// body params
	postBody = &appSessionContext

	//r, err := a.client.prepareRequest(ctx, path, httpMethod, postBody, headerParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	r, err := a.client.prepareRequest(ctx, path, httpMethod, postBody, headerParams)
	if err != nil {
		return retVal, nil, err
	}

	httpResponse, err := a.client.callAPI(r)
	if err != nil || httpResponse == nil {
		return retVal, httpResponse, err
	}

	respBody, err := _ioutil.ReadAll(httpResponse.Body)
	httpResponse.Body.Close()
	if err != nil {
		return retVal, httpResponse, err
	}

	newErr := GenericError{
		body:  respBody,
		error: httpResponse.Status,
	}
	if httpResponse.StatusCode == 201 {
		var v AppSessionContext
		err = a.client.decode(&v, respBody, httpResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return retVal, httpResponse, newErr
		}
		newErr.model = v
		return retVal, httpResponse, newErr
	}
	if httpResponse.StatusCode >= 300 {
		switch httpResponse.StatusCode {
		case 400, 401, 403, 404, 411, 413, 415, 429, 500, 503:
			var v ProblemDetails
			err = a.client.decode(&v, respBody, httpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return retVal, httpResponse, newErr
			}
			newErr.model = v
			return retVal, httpResponse, newErr
		}
		return retVal, httpResponse, newErr
	}

	err = a.client.decode(&retVal, respBody, httpResponse.Header.Get("Content-Type"))
	if err != nil {
		/*
			newErr = GenericError{
				body:  respBody,
				error: err.Error(),
			}
		*/
		newErr.error = err.Error()
		return retVal, httpResponse, newErr
	}
	return retVal, httpResponse, nil
}
